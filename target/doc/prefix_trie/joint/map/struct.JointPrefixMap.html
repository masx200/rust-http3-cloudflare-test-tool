<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A Joint prefix map, implemented as two separate prefix trees."><title>JointPrefixMap in prefix_trie::joint::map - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="prefix_trie" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.1 (ed61e7d7e 2025-11-07)" data-channel="1.91.1" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">JointPrefixMap</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../prefix_trie/index.html">prefix_<wbr>trie</a><span class="version">0.8.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Joint<wbr>Prefix<wbr>Map</a></h2><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.t1" title="t1">t1</a></li><li><a href="#structfield.t2" title="t2">t2</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.children" title="children">children</a></li><li><a href="#method.children_mut" title="children_mut">children_mut</a></li><li><a href="#method.clear" title="clear">clear</a></li><li><a href="#method.contains_key" title="contains_key">contains_key</a></li><li><a href="#method.cover" title="cover">cover</a></li><li><a href="#method.cover_keys" title="cover_keys">cover_keys</a></li><li><a href="#method.cover_values" title="cover_values">cover_values</a></li><li><a href="#method.covering_difference" title="covering_difference">covering_difference</a></li><li><a href="#method.difference" title="difference">difference</a></li><li><a href="#method.entry" title="entry">entry</a></li><li><a href="#method.get" title="get">get</a></li><li><a href="#method.get_key_value" title="get_key_value">get_key_value</a></li><li><a href="#method.get_lpm" title="get_lpm">get_lpm</a></li><li><a href="#method.get_lpm_mut" title="get_lpm_mut">get_lpm_mut</a></li><li><a href="#method.get_lpm_prefix" title="get_lpm_prefix">get_lpm_prefix</a></li><li><a href="#method.get_mut" title="get_mut">get_mut</a></li><li><a href="#method.get_spm" title="get_spm">get_spm</a></li><li><a href="#method.get_spm_prefix" title="get_spm_prefix">get_spm_prefix</a></li><li><a href="#method.insert" title="insert">insert</a></li><li><a href="#method.intersection" title="intersection">intersection</a></li><li><a href="#method.into_children" title="into_children">into_children</a></li><li><a href="#method.into_keys" title="into_keys">into_keys</a></li><li><a href="#method.into_values" title="into_values">into_values</a></li><li><a href="#method.is_empty" title="is_empty">is_empty</a></li><li><a href="#method.iter" title="iter">iter</a></li><li><a href="#method.iter_mut" title="iter_mut">iter_mut</a></li><li><a href="#method.keys" title="keys">keys</a></li><li><a href="#method.len" title="len">len</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.remove" title="remove">remove</a></li><li><a href="#method.remove_children" title="remove_children">remove_children</a></li><li><a href="#method.remove_keep_tree" title="remove_keep_tree">remove_keep_tree</a></li><li><a href="#method.retain" title="retain">retain</a></li><li><a href="#method.union" title="union">union</a></li><li><a href="#method.values" title="values">values</a></li><li><a href="#method.values_mut" title="values_mut">values_mut</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-JointPrefixMap%3CP,+T%3E" title="Clone">Clone</a></li><li><a href="#impl-Debug-for-JointPrefixMap%3CP,+T%3E" title="Debug">Debug</a></li><li><a href="#impl-Default-for-JointPrefixMap%3CP,+T%3E" title="Default">Default</a></li><li><a href="#impl-Eq-for-JointPrefixMap%3CP,+T%3E" title="Eq">Eq</a></li><li><a href="#impl-FromIterator%3C(P,+T)%3E-for-JointPrefixMap%3CP,+T%3E" title="FromIterator&#60;(P, T)&#62;">FromIterator&#60;(P, T)&#62;</a></li><li><a href="#impl-IntoIterator-for-%26JointPrefixMap%3CP,+T%3E" title="IntoIterator">IntoIterator</a></li><li><a href="#impl-IntoIterator-for-JointPrefixMap%3CP,+T%3E" title="IntoIterator">IntoIterator</a></li><li><a href="#impl-PartialEq%3CJointPrefixMap%3CP,+R%3E%3E-for-JointPrefixMap%3CP,+L%3E" title="PartialEq&#60;JointPrefixMap&#60;P, R&#62;&#62;">PartialEq&#60;JointPrefixMap&#60;P, R&#62;&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-JointPrefixMap%3CP,+T%3E" title="!Freeze">!Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-JointPrefixMap%3CP,+T%3E" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-Send-for-JointPrefixMap%3CP,+T%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-JointPrefixMap%3CP,+T%3E" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-JointPrefixMap%3CP,+T%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-JointPrefixMap%3CP,+T%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-IntoEither-for-T" title="IntoEither">IntoEither</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In prefix_<wbr>trie::<wbr>joint::<wbr>map</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">prefix_trie</a>::<wbr><a href="../index.html">joint</a>::<wbr><a href="index.html">map</a></div><h1>Struct <span class="struct">Joint<wbr>Prefix<wbr>Map</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/prefix_trie/joint\map/mod.rs.html#21-29">Source</a> </span></div><pre class="rust item-decl"><code>pub struct JointPrefixMap&lt;P, T&gt;<div class="where">where
    P: <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a>,</div>{
    pub t1: <a class="struct" href="../../map/struct.PrefixMap.html" title="struct prefix_trie::map::PrefixMap">PrefixMap</a>&lt;P::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P1" title="type prefix_trie::joint::JointPrefix::P1">P1</a>, T&gt;,
    pub t2: <a class="struct" href="../../map/struct.PrefixMap.html" title="struct prefix_trie::map::PrefixMap">PrefixMap</a>&lt;P::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P2" title="type prefix_trie::joint::JointPrefix::P2">P2</a>, T&gt;,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A Joint prefix map, implemented as two separate prefix trees.</p>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.t1" class="structfield section-header"><a href="#structfield.t1" class="anchor field">§</a><code>t1: <a class="struct" href="../../map/struct.PrefixMap.html" title="struct prefix_trie::map::PrefixMap">PrefixMap</a>&lt;P::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P1" title="type prefix_trie::joint::JointPrefix::P1">P1</a>, T&gt;</code></span><div class="docblock"><p>PrefixMap that corresponds to the first prefix type</p>
</div><span id="structfield.t2" class="structfield section-header"><a href="#structfield.t2" class="anchor field">§</a><code>t2: <a class="struct" href="../../map/struct.PrefixMap.html" title="struct prefix_trie::map::PrefixMap">PrefixMap</a>&lt;P::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P2" title="type prefix_trie::joint::JointPrefix::P2">P2</a>, T&gt;</code></span><div class="docblock"><p>PrefixMap that corresponds to the second prefix type</p>
</div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-JointPrefixMap%3CP,+T%3E" class="impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#43-596">Source</a><a href="#impl-JointPrefixMap%3CP,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P: <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a>, T&gt; <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#45-50">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Create an empty prefix map</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#70-72">Source</a><h4 class="code-header">pub fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of elements stored in <code>self</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>map: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::default();
map.insert(<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">1u32</span>);
map.insert(<span class="string">"192.168.1.0/25"</span>.parse()<span class="question-mark">?</span>, <span class="number">2u32</span>);
map.insert(<span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>, <span class="number">3u32</span>);
<span class="macro">assert_eq!</span>(map.len(), <span class="number">3</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#90-92">Source</a><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the map contains no elements.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>map: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
<span class="macro">assert!</span>(map.is_empty());
map.insert(<span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>, <span class="number">1u32</span>);
<span class="macro">assert!</span>(!map.is_empty());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#114-116">Source</a><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>&lt;'a&gt;(&amp;'a self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;P</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;'a T</a>&gt;</h4></section></summary><div class="docblock"><p>Get the value of an element by matching exactly on the prefix.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">1</span>));
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.1.128/25"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">2</span>));
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"0ca8:1::/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#135-137">Source</a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fn">get_mut</a>&lt;'a&gt;(&amp;'a mut self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;P</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;'a mut T</a>&gt;</h4></section></summary><div class="docblock"><p>Get a mutable reference to a value of an element by matching exactly on the prefix.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
<span class="kw">let </span>prefix = <span class="string">"2001::/32"</span>.parse()<span class="question-mark">?</span>;
pm.insert(prefix, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span>prefix), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">1</span>));
<span class="kw-2">*</span>pm.get_mut(<span class="kw-2">&amp;</span>prefix).unwrap() += <span class="number">1</span>;
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span>prefix), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">2</span>));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_key_value" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#155-157">Source</a><h4 class="code-header">pub fn <a href="#method.get_key_value" class="fn">get_key_value</a>&lt;'a&gt;(&amp;'a self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;P</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(P, <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;'a T</a>)&gt;</h4></section></summary><div class="docblock"><p>Get the value of an element by matching exactly on the prefix. Notice, that the returned
prefix may differ from the one provided in the host-part of the address.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
<span class="kw">let </span>prefix = <span class="string">"2001::/32"</span>.parse()<span class="question-mark">?</span>;
pm.insert(prefix, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(pm.get_key_value(<span class="kw-2">&amp;</span>prefix), <span class="prelude-val">Some</span>((prefix, <span class="kw-2">&amp;</span><span class="number">1</span>)));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_lpm" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#177-179">Source</a><h4 class="code-header">pub fn <a href="#method.get_lpm" class="fn">get_lpm</a>&lt;'a&gt;(&amp;'a self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;P</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(P, <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;'a T</a>)&gt;</h4></section></summary><div class="docblock"><p>Get a value of an element by using longest prefix matching</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(pm.get_lpm(<span class="kw-2">&amp;</span><span class="string">"192.168.1.1/32"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>((<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">1</span>)));
<span class="macro">assert_eq!</span>(pm.get_lpm(<span class="kw-2">&amp;</span><span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>((<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">1</span>)));
<span class="macro">assert_eq!</span>(pm.get_lpm(<span class="kw-2">&amp;</span><span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>((<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">2</span>)));
<span class="macro">assert_eq!</span>(pm.get_lpm(<span class="kw-2">&amp;</span><span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_lpm_mut" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#198-200">Source</a><h4 class="code-header">pub fn <a href="#method.get_lpm_mut" class="fn">get_lpm_mut</a>&lt;'a&gt;(&amp;'a mut self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;P</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(P, <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;'a mut T</a>)&gt;</h4></section></summary><div class="docblock"><p>Get a mutable reference to a value of an element by using longest prefix matching</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(pm.get_lpm(<span class="kw-2">&amp;</span><span class="string">"192.168.1.1/32"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>((<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">1</span>)));
<span class="kw-2">*</span>pm.get_lpm_mut(<span class="kw-2">&amp;</span><span class="string">"192.168.1.64/26"</span>.parse()<span class="question-mark">?</span>).unwrap().<span class="number">1 </span>+= <span class="number">1</span>;
<span class="macro">assert_eq!</span>(pm.get_lpm(<span class="kw-2">&amp;</span><span class="string">"192.168.1.1/32"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>((<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">2</span>)));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.contains_key" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#219-221">Source</a><h4 class="code-header">pub fn <a href="#method.contains_key" class="fn">contains_key</a>(&amp;self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;P</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Check if a key is present in the datastructure.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
<span class="macro">assert!</span>(pm.contains_key(<span class="kw-2">&amp;</span><span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>));
<span class="macro">assert!</span>(!pm.contains_key(<span class="kw-2">&amp;</span><span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>));
<span class="macro">assert!</span>(!pm.contains_key(<span class="kw-2">&amp;</span><span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>));
<span class="macro">assert!</span>(!pm.contains_key(<span class="kw-2">&amp;</span><span class="string">"192.168.1.128/25"</span>.parse()<span class="question-mark">?</span>));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_lpm_prefix" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#241-243">Source</a><h4 class="code-header">pub fn <a href="#method.get_lpm_prefix" class="fn">get_lpm_prefix</a>(&amp;self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;P</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;P&gt;</h4></section></summary><div class="docblock"><p>Get the longest prefix in the datastructure that matches the given <code>prefix</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(pm.get_lpm_prefix(<span class="kw-2">&amp;</span><span class="string">"192.168.1.1/32"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>));
<span class="macro">assert_eq!</span>(pm.get_lpm_prefix(<span class="kw-2">&amp;</span><span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>));
<span class="macro">assert_eq!</span>(pm.get_lpm_prefix(<span class="kw-2">&amp;</span><span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>));
<span class="macro">assert_eq!</span>(pm.get_lpm_prefix(<span class="kw-2">&amp;</span><span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_spm" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#262-264">Source</a><h4 class="code-header">pub fn <a href="#method.get_spm" class="fn">get_spm</a>&lt;'a&gt;(&amp;'a self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;P</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(P, <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;'a T</a>)&gt;</h4></section></summary><div class="docblock"><p>Get a value of an element by using shortest prefix matching.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(pm.get_spm(<span class="kw-2">&amp;</span><span class="string">"192.168.1.1/32"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>((<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">2</span>)));
<span class="macro">assert_eq!</span>(pm.get_spm(<span class="kw-2">&amp;</span><span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>((<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">2</span>)));
<span class="macro">assert_eq!</span>(pm.get_spm(<span class="kw-2">&amp;</span><span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>((<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">2</span>)));
<span class="macro">assert_eq!</span>(pm.get_spm(<span class="kw-2">&amp;</span><span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_spm_prefix" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#283-285">Source</a><h4 class="code-header">pub fn <a href="#method.get_spm_prefix" class="fn">get_spm_prefix</a>(&amp;self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;P</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;P&gt;</h4></section></summary><div class="docblock"><p>Get the shortest prefix in the datastructure that contains the given <code>prefix</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"192.168.1.1/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(pm.get_spm_prefix(<span class="kw-2">&amp;</span><span class="string">"192.168.1.1/32"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>));
<span class="macro">assert_eq!</span>(pm.get_spm_prefix(<span class="kw-2">&amp;</span><span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>));
<span class="macro">assert_eq!</span>(pm.get_spm_prefix(<span class="kw-2">&amp;</span><span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>));
<span class="macro">assert_eq!</span>(pm.get_spm_prefix(<span class="kw-2">&amp;</span><span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.insert" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#309-311">Source</a><h4 class="code-header">pub fn <a href="#method.insert" class="fn">insert</a>(&amp;mut self, prefix: P, value: T) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Insert a new item into the prefix-map. This function may return any value that existed
before.</p>
<p>In case the node already exists in the tree, its prefix will be replaced by the provided
argument. This allows you to store additional information in the host part of the prefix.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
<span class="macro">assert_eq!</span>(pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(pm.insert(<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(pm.insert(<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>), <span class="prelude-val">Some</span>(<span class="number">2</span>));
<span class="macro">assert_eq!</span>(pm.insert(<span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(pm.insert(<span class="string">"2001::1:0:0/97"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(pm.insert(<span class="string">"2001::1:0:0/97"</span>.parse()<span class="question-mark">?</span>, <span class="number">6</span>), <span class="prelude-val">Some</span>(<span class="number">5</span>));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.entry" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#335-346">Source</a><h4 class="code-header">pub fn <a href="#method.entry" class="fn">entry</a>(&amp;mut self, prefix: P) -&gt; <a class="enum" href="enum.Entry.html" title="enum prefix_trie::joint::map::Entry">Entry</a>&lt;'_, P, T&gt;</h4></section></summary><div class="docblock"><p>Gets the given key’s corresponding entry in the map for in-place manipulation. In case you
eventually insert an element into the map, this operation will also replace the prefix in
the node with the existing one. That is if you store additional information in the host part
of the address (the one that is masked out).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="number">1</span>]);
pm.entry(<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>).or_default().push(<span class="number">2</span>);
pm.entry(<span class="string">"192.168.1.0/25"</span>.parse()<span class="question-mark">?</span>).or_default().push(<span class="number">3</span>);
pm.entry(<span class="string">"c0a8:1::/24"</span>.parse()<span class="question-mark">?</span>).or_default().push(<span class="number">4</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>]));
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.1.0/25"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="macro">vec!</span>[<span class="number">3</span>]));
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"c0a8:1::/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="macro">vec!</span>[<span class="number">4</span>]));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.remove" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#369-371">Source</a><h4 class="code-header">pub fn <a href="#method.remove" class="fn">remove</a>(&amp;mut self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;P</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Removes a key from the map, returning the value at the key if the key was previously in the
map. In contrast to <a href="struct.JointPrefixMap.html#method.remove_keep_tree" title="method prefix_trie::joint::map::JointPrefixMap::remove_keep_tree"><code>Self::remove_keep_tree</code></a>, this operation will modify the tree
structure. As a result, this operation takes longer than <code>remove_keep_tree</code>, as does
inserting the same element again. However, future reads may be faster as less nodes need to
be traversed. Further, it reduces the memory footprint to its minimum.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
<span class="kw">let </span>prefix = <span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>;
pm.insert(prefix, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span>prefix), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">1</span>));
<span class="macro">assert_eq!</span>(pm.remove(<span class="kw-2">&amp;</span>prefix), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span>prefix), <span class="prelude-val">None</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.remove_keep_tree" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#397-399">Source</a><h4 class="code-header">pub fn <a href="#method.remove_keep_tree" class="fn">remove_keep_tree</a>(&amp;mut self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;P</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Removes a key from the map, returning the value at the key if the key was previously in the
map. In contrast to <a href="struct.JointPrefixMap.html#method.remove" title="method prefix_trie::joint::map::JointPrefixMap::remove"><code>Self::remove</code></a>, his operation will keep the tree structure as is, but
only remove the element from it. This allows any future <code>insert</code> on the same prefix to be
faster. However future reads from the tree might be a bit slower because they need to
traverse more nodes.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
<span class="kw">let </span>prefix = <span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>;
pm.insert(prefix, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span>prefix), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">1</span>));
<span class="macro">assert_eq!</span>(pm.remove_keep_tree(<span class="kw-2">&amp;</span>prefix), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span>prefix), <span class="prelude-val">None</span>);

<span class="comment">// future inserts of the same key are now faster!
</span>pm.insert(prefix, <span class="number">1</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.remove_children" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#424-426">Source</a><h4 class="code-header">pub fn <a href="#method.remove_children" class="fn">remove_children</a>(&amp;mut self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;P</a>)</h4></section></summary><div class="docblock"><p>Remove all entries that are contained within <code>prefix</code>. This will change the tree
structure. This operation is <code>O(n)</code>, as the entries must be freed up one-by-one.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
pm.insert(<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>);
pm.insert(<span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>);
pm.insert(<span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>);
pm.remove_children(<span class="kw-2">&amp;</span><span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">4</span>));
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">5</span>));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.clear" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#447-450">Source</a><h4 class="code-header">pub fn <a href="#method.clear" class="fn">clear</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Clear the map but keep the allocated memory.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
pm.insert(<span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>);
pm.clear();
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.retain" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#477-483">Source</a><h4 class="code-header">pub fn <a href="#method.retain" class="fn">retain</a>&lt;F&gt;(&amp;mut self, f: F)<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(P, <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Keep only the elements in the map that satisfy the given condition <code>f</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
pm.insert(<span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>);
pm.insert(<span class="string">"192.168.2.0/25"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>);
pm.insert(<span class="string">"2001::1:0:0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>);
pm.insert(<span class="string">"2001::1:0:0/25"</span>.parse()<span class="question-mark">?</span>, <span class="number">6</span>);
pm.retain(|<span class="kw">_</span>, t| <span class="kw-2">*</span>t % <span class="number">2 </span>== <span class="number">0</span>); <span class="comment">// only keep the even values.
</span><span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.1.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">2</span>));
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"192.168.2.0/25"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">4</span>));
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"2001::1:0:0/24"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(pm.get(<span class="kw-2">&amp;</span><span class="string">"2001::1:0:0/25"</span>.parse()<span class="question-mark">?</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">6</span>));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cover" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#530-535">Source</a><h4 class="code-header">pub fn <a href="#method.cover" class="fn">cover</a>&lt;'a, 'p&gt;(&amp;'a self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;'p P</a>) -&gt; <a class="enum" href="enum.Cover.html" title="enum prefix_trie::joint::map::Cover">Cover</a>&lt;'a, 'p, P, T&gt; <a href="#" class="tooltip" data-notable-ty="Cover&lt;&#39;a, &#39;p, P, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Iterate over all entries in the map that covers the given <code>prefix</code> (including <code>prefix</code>
itself if that is present in the map). The returned iterator yields <code>(&amp;'a P, &amp;'a T)</code>.</p>
<p>The iterator will always yield elements ordered by their prefix length, i.e., their depth in
the tree.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
<span class="kw">let </span>p0 = <span class="string">"10.0.0.0/8"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>p1 = <span class="string">"10.1.0.0/16"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>p2 = <span class="string">"10.1.1.0/24"</span>.parse()<span class="question-mark">?</span>;
pm.insert(p0, <span class="number">0</span>);
pm.insert(p1, <span class="number">1</span>);
pm.insert(p2, <span class="number">2</span>);
pm.insert(<span class="string">"10.1.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>); <span class="comment">// disjoint prefixes are not covered
</span>pm.insert(<span class="string">"10.1.1.0/25"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>); <span class="comment">// more specific prefixes are not covered
</span>pm.insert(<span class="string">"11.0.0.0/8"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>);  <span class="comment">// Branch points that don't contain values are skipped
</span><span class="macro">assert_eq!</span>(
    pm.cover(<span class="kw-2">&amp;</span>p2).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(),
    <span class="macro">vec!</span>[(p0, <span class="kw-2">&amp;</span><span class="number">0</span>), (p1, <span class="kw-2">&amp;</span><span class="number">1</span>), (p2, <span class="kw-2">&amp;</span><span class="number">2</span>)]
);</code></pre></div>
<p>This function also yields the root note <em>if</em> it is part of the map:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
<span class="kw">let </span>root = <span class="string">"0.0.0.0/0"</span>.parse()<span class="question-mark">?</span>;
pm.insert(root, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(pm.cover(<span class="kw-2">&amp;</span><span class="string">"10.0.0.0/8"</span>.parse()<span class="question-mark">?</span>).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(), <span class="macro">vec!</span>[(root, <span class="kw-2">&amp;</span><span class="number">0</span>)]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cover_keys" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#563-565">Source</a><h4 class="code-header">pub fn <a href="#method.cover_keys" class="fn">cover_keys</a>&lt;'a, 'p&gt;(&amp;'a self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;'p P</a>) -&gt; <a class="struct" href="struct.CoverKeys.html" title="struct prefix_trie::joint::map::CoverKeys">CoverKeys</a>&lt;'a, 'p, P, T&gt; <a href="#" class="tooltip" data-notable-ty="CoverKeys&lt;&#39;a, &#39;p, P, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Iterate over all keys (prefixes) in the map that covers the given <code>prefix</code> (including
<code>prefix</code> itself if that is present in the map). The returned iterator yields <code>&amp;'a P</code>.</p>
<p>The iterator will always yield elements ordered by their prefix length, i.e., their depth in
the tree.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
<span class="kw">let </span>p0 = <span class="string">"10.0.0.0/8"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>p1 = <span class="string">"10.1.0.0/16"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>p2 = <span class="string">"10.1.1.0/24"</span>.parse()<span class="question-mark">?</span>;
pm.insert(p0, <span class="number">0</span>);
pm.insert(p1, <span class="number">1</span>);
pm.insert(p2, <span class="number">2</span>);
pm.insert(<span class="string">"10.1.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>); <span class="comment">// disjoint prefixes are not covered
</span>pm.insert(<span class="string">"10.1.1.0/25"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>); <span class="comment">// more specific prefixes are not covered
</span>pm.insert(<span class="string">"11.0.0.0/8"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>);  <span class="comment">// Branch points that don't contain values are skipped
</span><span class="macro">assert_eq!</span>(pm.cover_keys(<span class="kw-2">&amp;</span>p2).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(), <span class="macro">vec!</span>[p0, p1, p2]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cover_values" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#593-595">Source</a><h4 class="code-header">pub fn <a href="#method.cover_values" class="fn">cover_values</a>&lt;'a, 'p&gt;(
    &amp;'a self,
    prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;'p P</a>,
) -&gt; <a class="struct" href="struct.CoverValues.html" title="struct prefix_trie::joint::map::CoverValues">CoverValues</a>&lt;'a, 'p, P, T&gt; <a href="#" class="tooltip" data-notable-ty="CoverValues&lt;&#39;a, &#39;p, P, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Iterate over all values in the map that covers the given <code>prefix</code> (including <code>prefix</code>
itself if that is present in the map). The returned iterator yields <code>&amp;'a T</code>.</p>
<p>The iterator will always yield elements ordered by their prefix length, i.e., their depth in
the tree.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
<span class="kw">let </span>p0 = <span class="string">"10.0.0.0/8"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>p1 = <span class="string">"10.1.0.0/16"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>p2 = <span class="string">"10.1.1.0/24"</span>.parse()<span class="question-mark">?</span>;
pm.insert(p0, <span class="number">0</span>);
pm.insert(p1, <span class="number">1</span>);
pm.insert(p2, <span class="number">2</span>);
pm.insert(<span class="string">"10.1.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>); <span class="comment">// disjoint prefixes are not covered
</span>pm.insert(<span class="string">"10.1.1.0/25"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>); <span class="comment">// more specific prefixes are not covered
</span>pm.insert(<span class="string">"11.0.0.0/8"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>);  <span class="comment">// Branch points that don't contain values are skipped
</span><span class="macro">assert_eq!</span>(pm.cover_values(<span class="kw-2">&amp;</span>p2).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(), <span class="macro">vec!</span>[<span class="kw-2">&amp;</span><span class="number">0</span>, <span class="kw-2">&amp;</span><span class="number">1</span>, <span class="kw-2">&amp;</span><span class="number">2</span>]);</code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-JointPrefixMap%3CP,+T%3E-1" class="impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#598-1217">Source</a><a href="#impl-JointPrefixMap%3CP,+T%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;P: <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a>, T&gt; <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.iter" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#632-634">Source</a><h4 class="code-header">pub fn <a href="#method.iter" class="fn">iter</a>(&amp;self) -&gt; <a class="struct" href="struct.Iter.html" title="struct prefix_trie::joint::map::Iter">Iter</a>&lt;'_, P, T&gt; <a href="#" class="tooltip" data-notable-ty="Iter&lt;&#39;_, P, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>An iterator visiting all key-value pairs in lexicographic order. The iterator element type
is <code>(&amp;P, &amp;T)</code>. Elements of the first prefix are yielded before those of the second prefix.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"2001::1:0:0/97"</span>.parse()<span class="question-mark">?</span>, <span class="number">6</span>);
pm.insert(<span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>, <span class="number">7</span>);
pm.insert(<span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
pm.insert(<span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>);
pm.insert(<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>);
pm.insert(<span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>);
<span class="macro">assert_eq!</span>(
    pm.iter().collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(),
    <span class="macro">vec!</span>[
        (<span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">1</span>),
        (<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">2</span>),
        (<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">4</span>),
        (<span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">3</span>),
        (<span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">5</span>),
        (<span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">7</span>),
        (<span class="string">"2001::1:0:0/97"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">6</span>),
    ]
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iter_mut" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#667-672">Source</a><h4 class="code-header">pub fn <a href="#method.iter_mut" class="fn">iter_mut</a>(&amp;mut self) -&gt; <a class="struct" href="struct.IterMut.html" title="struct prefix_trie::joint::map::IterMut">IterMut</a>&lt;'_, P, T&gt; <a href="#" class="tooltip" data-notable-ty="IterMut&lt;&#39;_, P, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Get a mutable iterator over all key-value pairs. The order of this iterator is lexicographic.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"2001::1:0:0/97"</span>.parse()<span class="question-mark">?</span>, <span class="number">6</span>);
pm.insert(<span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>, <span class="number">7</span>);
pm.insert(<span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
pm.insert(<span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>);
pm.insert(<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>);
pm.insert(<span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>);
pm.iter_mut().for_each(|(<span class="kw">_</span>, v)| <span class="kw-2">*</span>v += <span class="number">1</span>);
<span class="macro">assert_eq!</span>(
    pm.iter().collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(),
    <span class="macro">vec!</span>[
        (<span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">2</span>),
        (<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">3</span>),
        (<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">5</span>),
        (<span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">4</span>),
        (<span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">6</span>),
        (<span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">8</span>),
        (<span class="string">"2001::1:0:0/97"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">7</span>),
    ]
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.keys" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#707-709">Source</a><h4 class="code-header">pub fn <a href="#method.keys" class="fn">keys</a>(&amp;self) -&gt; <a class="struct" href="struct.Keys.html" title="struct prefix_trie::joint::map::Keys">Keys</a>&lt;'_, P, T&gt; <a href="#" class="tooltip" data-notable-ty="Keys&lt;&#39;_, P, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>An iterator visiting all keys in lexicographic order. The iterator element type is
<code>&amp;P</code>. Elements of the first prefix are yielded before those of the second one.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"2001::1:0:0/97"</span>.parse()<span class="question-mark">?</span>, <span class="number">6</span>);
pm.insert(<span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>, <span class="number">7</span>);
pm.insert(<span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
pm.insert(<span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>);
pm.insert(<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>);
pm.insert(<span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>);
<span class="macro">assert_eq!</span>(
    pm.keys().collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(),
    <span class="macro">vec!</span>[
        <span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>,
        <span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>,
        <span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>,
        <span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>,
        <span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>,
        <span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>,
        <span class="string">"2001::1:0:0/97"</span>.parse()<span class="question-mark">?</span>,
    ]
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.into_keys" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#744-748">Source</a><h4 class="code-header">pub fn <a href="#method.into_keys" class="fn">into_keys</a>(self) -&gt; <a class="struct" href="struct.IntoKeys.html" title="struct prefix_trie::joint::map::IntoKeys">IntoKeys</a>&lt;P, T&gt; <a href="#" class="tooltip" data-notable-ty="IntoKeys&lt;P, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Creates a consuming iterator visiting all keys in lexicographic order. The iterator element
type is <code>P</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"2001::1:0:0/97"</span>.parse()<span class="question-mark">?</span>, <span class="number">6</span>);
pm.insert(<span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>, <span class="number">7</span>);
pm.insert(<span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
pm.insert(<span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>);
pm.insert(<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>);
pm.insert(<span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>);
<span class="macro">assert_eq!</span>(
    pm.into_keys().collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(),
    <span class="macro">vec!</span>[
        <span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>,
        <span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>,
        <span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>,
        <span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>,
        <span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>,
        <span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>,
        <span class="string">"2001::1:0:0/97"</span>.parse()<span class="question-mark">?</span>,
    ]
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.values" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#772-774">Source</a><h4 class="code-header">pub fn <a href="#method.values" class="fn">values</a>(&amp;self) -&gt; <a class="struct" href="struct.Values.html" title="struct prefix_trie::joint::map::Values">Values</a>&lt;'_, P, T&gt; <a href="#" class="tooltip" data-notable-ty="Values&lt;&#39;_, P, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>An iterator visiting all values in lexicographic order. The iterator element type is
<code>&amp;P</code>. Elements of the first prefix are yielded before those of the second one.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"2001::1:0:0/97"</span>.parse()<span class="question-mark">?</span>, <span class="number">6</span>);
pm.insert(<span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>, <span class="number">7</span>);
pm.insert(<span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
pm.insert(<span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>);
pm.insert(<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>);
pm.insert(<span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>);
<span class="macro">assert_eq!</span>(pm.values().collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(), <span class="macro">vec!</span>[<span class="kw-2">&amp;</span><span class="number">1</span>, <span class="kw-2">&amp;</span><span class="number">2</span>, <span class="kw-2">&amp;</span><span class="number">4</span>, <span class="kw-2">&amp;</span><span class="number">3</span>, <span class="kw-2">&amp;</span><span class="number">5</span>, <span class="kw-2">&amp;</span><span class="number">7</span>, <span class="kw-2">&amp;</span><span class="number">6</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.into_values" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#798-802">Source</a><h4 class="code-header">pub fn <a href="#method.into_values" class="fn">into_values</a>(self) -&gt; <a class="struct" href="struct.IntoValues.html" title="struct prefix_trie::joint::map::IntoValues">IntoValues</a>&lt;P, T&gt; <a href="#" class="tooltip" data-notable-ty="IntoValues&lt;P, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Creates a consuming iterator visiting all values in lexicographic order. The iterator
element type is <code>P</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"2001::1:0:0/97"</span>.parse()<span class="question-mark">?</span>, <span class="number">6</span>);
pm.insert(<span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>, <span class="number">7</span>);
pm.insert(<span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
pm.insert(<span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>);
pm.insert(<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>);
pm.insert(<span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>);
<span class="macro">assert_eq!</span>(pm.into_values().collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(), <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.values_mut" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#825-829">Source</a><h4 class="code-header">pub fn <a href="#method.values_mut" class="fn">values_mut</a>(&amp;mut self) -&gt; <a class="struct" href="struct.ValuesMut.html" title="struct prefix_trie::joint::map::ValuesMut">ValuesMut</a>&lt;'_, P, T&gt; <a href="#" class="tooltip" data-notable-ty="ValuesMut&lt;&#39;_, P, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Get a mutable iterator over all values. The order of this iterator is lexicographic.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"2001::1:0:0/97"</span>.parse()<span class="question-mark">?</span>, <span class="number">6</span>);
pm.insert(<span class="string">"2001::1:0:0/96"</span>.parse()<span class="question-mark">?</span>, <span class="number">7</span>);
pm.insert(<span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
pm.insert(<span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>);
pm.insert(<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>);
pm.insert(<span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>);

pm.values_mut().for_each(|v| <span class="kw-2">*</span>v += <span class="number">1</span>);
<span class="macro">assert_eq!</span>(pm.values().collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(), <span class="macro">vec!</span>[<span class="kw-2">&amp;</span><span class="number">2</span>, <span class="kw-2">&amp;</span><span class="number">3</span>, <span class="kw-2">&amp;</span><span class="number">5</span>, <span class="kw-2">&amp;</span><span class="number">4</span>, <span class="kw-2">&amp;</span><span class="number">6</span>, <span class="kw-2">&amp;</span><span class="number">8</span>, <span class="kw-2">&amp;</span><span class="number">7</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.children" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#885-896">Source</a><h4 class="code-header">pub fn <a href="#method.children" class="fn">children</a>&lt;'a&gt;(&amp;'a self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;P</a>) -&gt; <a class="struct" href="struct.Iter.html" title="struct prefix_trie::joint::map::Iter">Iter</a>&lt;'a, P, T&gt; <a href="#" class="tooltip" data-notable-ty="Iter&lt;&#39;a, P, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Get an iterator over the node itself and all children. All elements returned have a prefix
that is contained within <code>prefix</code> itself (or are the same). The iterator yields references
to both keys and values, i.e., type <code>(&amp;'a P, &amp;'a T)</code>. The iterator yields elements in
lexicographic order.</p>
<p><strong>Note</strong>: Consider using <a href="../../trieview/trait.AsView.html#method.view_at" title="method prefix_trie::trieview::AsView::view_at"><code>crate::AsView::view_at</code></a> as an alternative.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
pm.insert(<span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>);
pm.insert(<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>);
pm.insert(<span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>);
<span class="macro">assert_eq!</span>(
    pm.children(<span class="kw-2">&amp;</span><span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(),
    <span class="macro">vec!</span>[
        (<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">2</span>),
        (<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">4</span>),
    ]
);</code></pre></div>
<p>If the prefix is not present in the tree, and there are no children, the iterator will be
empty:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"2001::/32"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"2001::/48"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(
    pm.children(<span class="kw-2">&amp;</span><span class="string">"2001::/24"</span>.parse()<span class="question-mark">?</span>).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(),
    <span class="macro">vec!</span>[
        (<span class="string">"2001::/32"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">1</span>),
        (<span class="string">"2001::/48"</span>.parse()<span class="question-mark">?</span>, <span class="kw-2">&amp;</span><span class="number">2</span>),
    ]
);
<span class="macro">assert_eq!</span>(pm.children(<span class="kw-2">&amp;</span><span class="string">"2001::/96"</span>.parse()<span class="question-mark">?</span>).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(), <span class="macro">vec!</span>[]);
<span class="macro">assert_eq!</span>(pm.children(<span class="kw-2">&amp;</span><span class="string">"1111::/24"</span>.parse()<span class="question-mark">?</span>).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(), <span class="macro">vec!</span>[]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.children_mut" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#949-960">Source</a><h4 class="code-header">pub fn <a href="#method.children_mut" class="fn">children_mut</a>&lt;'a&gt;(&amp;'a mut self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;P</a>) -&gt; <a class="struct" href="struct.IterMut.html" title="struct prefix_trie::joint::map::IterMut">IterMut</a>&lt;'a, P, T&gt; <a href="#" class="tooltip" data-notable-ty="IterMut&lt;&#39;a, P, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Get an iterator of mutable references of the node itself and all its children. All elements
returned have a prefix that is contained within <code>prefix</code> itself (or are the same). The
iterator yields references to the keys, and mutable references to the values, i.e., type
<code>(&amp;'a P, &amp;'a mut T)</code>. The iterator yields elements in lexicographic order.</p>
<p><strong>Note</strong>: Consider using <a href="../../trieview/trait.AsViewMut.html#method.view_mut_at" title="method prefix_trie::trieview::AsViewMut::view_mut_at"><code>crate::AsViewMut::view_mut_at</code></a> as an alternative.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
pm.insert(<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>);
pm.insert(<span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>);
pm.insert(<span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>);
pm.children_mut(<span class="kw-2">&amp;</span><span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>).for_each(|(<span class="kw">_</span>, x)| <span class="kw-2">*</span>x <span class="kw-2">*</span>= <span class="number">10</span>);
<span class="macro">assert_eq!</span>(
    pm.into_iter().collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(),
    <span class="macro">vec!</span>[
        (<span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>),
        (<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">20</span>),
        (<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">30</span>),
        (<span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>),
        (<span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>),
    ]
);</code></pre></div>
<p>If the prefix is not present in the tree, and there are no children, the iterator will be
empty:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"2001::/32"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"2001::/48"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(pm.children_mut(<span class="kw-2">&amp;</span><span class="string">"2001::/96"</span>.parse()<span class="question-mark">?</span>).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(), <span class="macro">vec!</span>[]);
<span class="macro">assert_eq!</span>(pm.children_mut(<span class="kw-2">&amp;</span><span class="string">"1111::/24"</span>.parse()<span class="question-mark">?</span>).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(), <span class="macro">vec!</span>[]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.into_children" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#1013-1024">Source</a><h4 class="code-header">pub fn <a href="#method.into_children" class="fn">into_children</a>(self, prefix: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;P</a>) -&gt; <a class="struct" href="struct.IntoIter.html" title="struct prefix_trie::joint::map::IntoIter">IntoIter</a>&lt;P, T&gt; <a href="#" class="tooltip" data-notable-ty="IntoIter&lt;P, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Get an iterator over the node itself and all children with a value. All elements returned
have a prefix that is contained within <code>prefix</code> itself (or are the same). This function will
consume <code>self</code>, returning an iterator over all owned children.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"192.168.0.0/22"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
pm.insert(<span class="string">"192.168.2.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">3</span>);
pm.insert(<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>);
pm.insert(<span class="string">"192.168.2.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">5</span>);
<span class="macro">assert_eq!</span>(
    pm.into_children(<span class="kw-2">&amp;</span><span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(),
    <span class="macro">vec!</span>[
        (<span class="string">"192.168.0.0/23"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>),
        (<span class="string">"192.168.0.0/24"</span>.parse()<span class="question-mark">?</span>, <span class="number">4</span>),
    ]
);</code></pre></div>
<p>If the prefix is not present in the tree, and there are no children, the iterator will be
empty:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>pm: JointPrefixMap&lt;ipnet::IpNet, <span class="kw">_</span>&gt; = JointPrefixMap::new();
pm.insert(<span class="string">"2001::/32"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>);
pm.insert(<span class="string">"2001::/48"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(
    pm.clone().into_children(<span class="kw-2">&amp;</span><span class="string">"2001::/24"</span>.parse()<span class="question-mark">?</span>).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(),
    <span class="macro">vec!</span>[
        (<span class="string">"2001::/32"</span>.parse()<span class="question-mark">?</span>, <span class="number">1</span>),
        (<span class="string">"2001::/48"</span>.parse()<span class="question-mark">?</span>, <span class="number">2</span>),
    ]
);
<span class="macro">assert_eq!</span>(pm.clone().into_children(<span class="kw-2">&amp;</span><span class="string">"2001::/96"</span>.parse()<span class="question-mark">?</span>).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(), <span class="macro">vec!</span>[]);
<span class="macro">assert_eq!</span>(pm.clone().into_children(<span class="kw-2">&amp;</span><span class="string">"1111::/24"</span>.parse()<span class="question-mark">?</span>).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(), <span class="macro">vec!</span>[]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.union" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#1077-1082">Source</a><h4 class="code-header">pub fn <a href="#method.union" class="fn">union</a>&lt;'a, R&gt;(
    &amp;'a self,
    other: &amp;'a <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, R&gt;,
) -&gt; <a class="struct" href="struct.Union.html" title="struct prefix_trie::joint::map::Union">Union</a>&lt;'a, P, T, R&gt; <a href="#" class="tooltip" data-notable-ty="Union&lt;&#39;a, P, T, R&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Iterate over the union of two joint prefix maps. This is roughly equivalent to calling
<code>self.t1.view().union(&amp;other.t1).chain(self.t2.view().union(&amp;other.t2))</code>.</p>
<p>If a prefix is present in both trees, the iterator will yield both elements. Otherwise, the
iterator will yield the element of one map together with the longest prefix match in
the other map. Elements are of type <a href="enum.UnionItem.html" title="enum prefix_trie::joint::map::UnionItem"><code>UnionItem</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">macro_rules!</span> net { (<span class="macro-nonterminal">$x</span>:literal) =&gt; {<span class="macro-nonterminal">$x</span>.parse::&lt;ipnet::IpNet&gt;().unwrap()}; }

<span class="kw">let </span><span class="kw-2">mut </span>map_a: JointPrefixMap&lt;ipnet::IpNet, usize&gt; = JointPrefixMap::from_iter([
    (<span class="macro">net!</span>(<span class="string">"2001::1:0:0/96"</span>), <span class="number">1</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/22"</span>), <span class="number">2</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/24"</span>), <span class="number">3</span>),
]);
<span class="kw">let </span><span class="kw-2">mut </span>map_b: JointPrefixMap&lt;ipnet::IpNet, <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str&gt; = JointPrefixMap::from_iter([
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/22"</span>), <span class="string">"a"</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/23"</span>), <span class="string">"b"</span>),
]);
<span class="macro">assert_eq!</span>(
    map_a.union(<span class="kw-2">&amp;</span>map_b).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(),
    <span class="macro">vec!</span>[
        UnionItem::Both{
            prefix: <span class="macro">net!</span>(<span class="string">"192.168.0.0/22"</span>),
            left: <span class="kw-2">&amp;</span><span class="number">2</span>,
            right: <span class="kw-2">&amp;</span><span class="string">"a"</span>,
        },
        UnionItem::Right{
            prefix: <span class="macro">net!</span>(<span class="string">"192.168.0.0/23"</span>),
            left: <span class="prelude-val">Some</span>((<span class="macro">net!</span>(<span class="string">"192.168.0.0/22"</span>), <span class="kw-2">&amp;</span><span class="number">2</span>)),
            right: <span class="kw-2">&amp;</span><span class="string">"b"</span>,
        },
        UnionItem::Left{
            prefix: <span class="macro">net!</span>(<span class="string">"192.168.0.0/24"</span>),
            left: <span class="kw-2">&amp;</span><span class="number">3</span>,
            right: <span class="prelude-val">Some</span>((<span class="macro">net!</span>(<span class="string">"192.168.0.0/23"</span>), <span class="kw-2">&amp;</span><span class="string">"b"</span>)),
        },
        UnionItem::Left{
            prefix: <span class="macro">net!</span>(<span class="string">"2001::1:0:0/96"</span>),
            left: <span class="kw-2">&amp;</span><span class="number">1</span>,
            right: <span class="prelude-val">None</span>,
        },
    ]
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.intersection" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#1122-1130">Source</a><h4 class="code-header">pub fn <a href="#method.intersection" class="fn">intersection</a>&lt;'a, R&gt;(
    &amp;'a self,
    other: &amp;'a <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, R&gt;,
) -&gt; <a class="struct" href="struct.Intersection.html" title="struct prefix_trie::joint::map::Intersection">Intersection</a>&lt;'a, P, T, R&gt; <a href="#" class="tooltip" data-notable-ty="Intersection&lt;&#39;a, P, T, R&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Iterate over the intersection of two joint prefix maps. This is roughly equivalent to
calling <code>self.t1.view().intersection(&amp;other.t1).chain(self.t2.view().intersection(&amp;other.t2))</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">macro_rules!</span> net { (<span class="macro-nonterminal">$x</span>:literal) =&gt; {<span class="macro-nonterminal">$x</span>.parse::&lt;ipnet::IpNet&gt;().unwrap()}; }

<span class="kw">let </span><span class="kw-2">mut </span>map_a: JointPrefixMap&lt;ipnet::IpNet, usize&gt; = JointPrefixMap::from_iter([
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/20"</span>), <span class="number">1</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/22"</span>), <span class="number">2</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/24"</span>), <span class="number">3</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.2.0/23"</span>), <span class="number">4</span>),
    (<span class="macro">net!</span>(<span class="string">"2001::1:0:0/96"</span>), <span class="number">5</span>),
    (<span class="macro">net!</span>(<span class="string">"2001::1:0:0/97"</span>), <span class="number">6</span>),
]);
<span class="kw">let </span><span class="kw-2">mut </span>map_b: JointPrefixMap&lt;ipnet::IpNet, <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str&gt; = JointPrefixMap::from_iter([
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/20"</span>), <span class="string">"a"</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/22"</span>), <span class="string">"b"</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/23"</span>), <span class="string">"c"</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/24"</span>), <span class="string">"d"</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.2.0/24"</span>), <span class="string">"e"</span>),
    (<span class="macro">net!</span>(<span class="string">"2001::1:0:0/96"</span>), <span class="string">"f"</span>),
    (<span class="macro">net!</span>(<span class="string">"2001::0:0:0/97"</span>), <span class="string">"g"</span>),
]);
<span class="macro">assert_eq!</span>(
    map_a.intersection(<span class="kw-2">&amp;</span>map_b).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(),
    <span class="macro">vec!</span>[
        (<span class="macro">net!</span>(<span class="string">"192.168.0.0/20"</span>), <span class="kw-2">&amp;</span><span class="number">1</span>, <span class="kw-2">&amp;</span><span class="string">"a"</span>),
        (<span class="macro">net!</span>(<span class="string">"192.168.0.0/22"</span>), <span class="kw-2">&amp;</span><span class="number">2</span>, <span class="kw-2">&amp;</span><span class="string">"b"</span>),
        (<span class="macro">net!</span>(<span class="string">"192.168.0.0/24"</span>), <span class="kw-2">&amp;</span><span class="number">3</span>, <span class="kw-2">&amp;</span><span class="string">"d"</span>),
        (<span class="macro">net!</span>(<span class="string">"2001::1:0:0/96"</span>), <span class="kw-2">&amp;</span><span class="number">5</span>, <span class="kw-2">&amp;</span><span class="string">"f"</span>),
    ]
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.difference" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#1169-1174">Source</a><h4 class="code-header">pub fn <a href="#method.difference" class="fn">difference</a>&lt;'a, R&gt;(
    &amp;'a self,
    other: &amp;'a <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, R&gt;,
) -&gt; <a class="struct" href="struct.Difference.html" title="struct prefix_trie::joint::map::Difference">Difference</a>&lt;'a, P, T, R&gt; <a href="#" class="tooltip" data-notable-ty="Difference&lt;&#39;a, P, T, R&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Iterate over the all elements in <code>self</code> that are not present in <code>other</code>. Each item will
return a reference to the prefix and value in <code>self</code>, as well as the longest prefix match of
<code>other</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">macro_rules!</span> net { (<span class="macro-nonterminal">$x</span>:literal) =&gt; {<span class="macro-nonterminal">$x</span>.parse::&lt;ipnet::IpNet&gt;().unwrap()}; }

<span class="kw">let </span><span class="kw-2">mut </span>map_a: JointPrefixMap&lt;ipnet::IpNet, usize&gt; = JointPrefixMap::from_iter([
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/20"</span>), <span class="number">1</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/22"</span>), <span class="number">2</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/24"</span>), <span class="number">3</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.2.0/23"</span>), <span class="number">4</span>),
    (<span class="macro">net!</span>(<span class="string">"2001::1:0:0/96"</span>), <span class="number">5</span>),
    (<span class="macro">net!</span>(<span class="string">"2001::1:0:0/97"</span>), <span class="number">6</span>),
]);
<span class="kw">let </span><span class="kw-2">mut </span>map_b: JointPrefixMap&lt;ipnet::IpNet, <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str&gt; = JointPrefixMap::from_iter([
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/20"</span>), <span class="string">"a"</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/22"</span>), <span class="string">"b"</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/23"</span>), <span class="string">"c"</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.2.0/24"</span>), <span class="string">"d"</span>),
    (<span class="macro">net!</span>(<span class="string">"2001::1:0:0/96"</span>), <span class="string">"e"</span>),
]);
<span class="macro">assert_eq!</span>(
    map_a.difference(<span class="kw-2">&amp;</span>map_b).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(),
    <span class="macro">vec!</span>[
        DifferenceItem { prefix: <span class="macro">net!</span>(<span class="string">"192.168.0.0/24"</span>), value: <span class="kw-2">&amp;</span><span class="number">3</span>, right: <span class="prelude-val">Some</span>((<span class="macro">net!</span>(<span class="string">"192.168.0.0/23"</span>), <span class="kw-2">&amp;</span><span class="string">"c"</span>))},
        DifferenceItem { prefix: <span class="macro">net!</span>(<span class="string">"192.168.2.0/23"</span>), value: <span class="kw-2">&amp;</span><span class="number">4</span>, right: <span class="prelude-val">Some</span>((<span class="macro">net!</span>(<span class="string">"192.168.0.0/22"</span>), <span class="kw-2">&amp;</span><span class="string">"b"</span>))},
        DifferenceItem { prefix: <span class="macro">net!</span>(<span class="string">"2001::1:0:0/97"</span>), value: <span class="kw-2">&amp;</span><span class="number">6</span>, right: <span class="prelude-val">Some</span>((<span class="macro">net!</span>(<span class="string">"2001::1:0:0/96"</span>), <span class="kw-2">&amp;</span><span class="string">"e"</span>))},
    ]
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.covering_difference" class="method"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#1208-1216">Source</a><h4 class="code-header">pub fn <a href="#method.covering_difference" class="fn">covering_difference</a>&lt;'a, R&gt;(
    &amp;'a self,
    other: &amp;'a <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, R&gt;,
) -&gt; <a class="struct" href="struct.CoveringDifference.html" title="struct prefix_trie::joint::map::CoveringDifference">CoveringDifference</a>&lt;'a, P, T, R&gt; <a href="#" class="tooltip" data-notable-ty="CoveringDifference&lt;&#39;a, P, T, R&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Iterate over the all elements in <code>self</code> that are not covered by <code>other</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">macro_rules!</span> net { (<span class="macro-nonterminal">$x</span>:literal) =&gt; {<span class="macro-nonterminal">$x</span>.parse::&lt;ipnet::IpNet&gt;().unwrap()}; }

<span class="kw">let </span><span class="kw-2">mut </span>map_a: JointPrefixMap&lt;ipnet::IpNet, usize&gt; = JointPrefixMap::from_iter([
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/20"</span>), <span class="number">1</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/22"</span>), <span class="number">2</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/24"</span>), <span class="number">3</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.2.0/23"</span>), <span class="number">4</span>),
    (<span class="macro">net!</span>(<span class="string">"2001::0:0:0/95"</span>), <span class="number">5</span>),
    (<span class="macro">net!</span>(<span class="string">"2001::1:0:0/96"</span>), <span class="number">6</span>),
    (<span class="macro">net!</span>(<span class="string">"2001::1:0:0/97"</span>), <span class="number">7</span>),
]);
<span class="kw">let </span><span class="kw-2">mut </span>map_b: JointPrefixMap&lt;ipnet::IpNet, <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str&gt; = JointPrefixMap::from_iter([
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/21"</span>), <span class="string">"a"</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/22"</span>), <span class="string">"b"</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.0.0/23"</span>), <span class="string">"c"</span>),
    (<span class="macro">net!</span>(<span class="string">"192.168.2.0/24"</span>), <span class="string">"d"</span>),
    (<span class="macro">net!</span>(<span class="string">"2001::1:0:0/96"</span>), <span class="string">"e"</span>),
]);
<span class="macro">assert_eq!</span>(
    map_a.covering_difference(<span class="kw-2">&amp;</span>map_b).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(),
    <span class="macro">vec!</span>[(<span class="macro">net!</span>(<span class="string">"192.168.0.0/20"</span>), <span class="kw-2">&amp;</span><span class="number">1</span>), (<span class="macro">net!</span>(<span class="string">"2001::0:0:0/95"</span>), <span class="kw-2">&amp;</span><span class="number">5</span>)]
);</code></pre></div></div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-JointPrefixMap%3CP,+T%3E" class="impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#12">Source</a><a href="#impl-Clone-for-JointPrefixMap%3CP,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P, T: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;<div class="where">where
    P: <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a> + <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    P::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P1" title="type prefix_trie::joint::JointPrefix::P1">P1</a>: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    P::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P2" title="type prefix_trie::joint::JointPrefix::P2">P2</a>: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#12">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;</h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/1.91.1/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.1/src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.91.1/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-JointPrefixMap%3CP,+T%3E" class="impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#12">Source</a><a href="#impl-Debug-for-JointPrefixMap%3CP,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P, T: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;<div class="where">where
    P: <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a> + <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>,
    P::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P1" title="type prefix_trie::joint::JointPrefix::P1">P1</a>: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>,
    P::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P2" title="type prefix_trie::joint::JointPrefix::P2">P2</a>: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#12">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.91.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.91.1/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-JointPrefixMap%3CP,+T%3E" class="impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#31-41">Source</a><a href="#impl-Default-for-JointPrefixMap%3CP,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;<div class="where">where
    P: <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#35-40">Source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.91.1/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3C(P,+T)%3E-for-JointPrefixMap%3CP,+T%3E" class="impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/iter.rs.html#275-283">Source</a><a href="#impl-FromIterator%3C(P,+T)%3E-for-JointPrefixMap%3CP,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P: <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a>, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.tuple.html">(P, T)</a>&gt; for <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter" class="method trait-impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/iter.rs.html#276-282">Source</a><a href="#method.from_iter" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.tuple.html">(P, T)</a>&gt;&gt;(iter: I) -&gt; Self</h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26JointPrefixMap%3CP,+T%3E" class="impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/iter.rs.html#196-207">Source</a><a href="#impl-IntoIterator-for-%26JointPrefixMap%3CP,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, P: <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a>, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Item-1" class="associatedtype trait-impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/iter.rs.html#197">Source</a><a href="#associatedtype.Item-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = (P, <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;'a T</a>)</h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle" open><summary><section id="associatedtype.IntoIter-1" class="associatedtype trait-impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/iter.rs.html#199">Source</a><a href="#associatedtype.IntoIter-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.Iter.html" title="struct prefix_trie::joint::map::Iter">Iter</a>&lt;'a, P, T&gt;</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter-1" class="method trait-impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/iter.rs.html#201-206">Source</a><a href="#method.into_iter-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-JointPrefixMap%3CP,+T%3E" class="impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/iter.rs.html#183-194">Source</a><a href="#impl-IntoIterator-for-JointPrefixMap%3CP,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P: <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a>, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Item" class="associatedtype trait-impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/iter.rs.html#184">Source</a><a href="#associatedtype.Item" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.tuple.html">(P, T)</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle" open><summary><section id="associatedtype.IntoIter" class="associatedtype trait-impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/iter.rs.html#186">Source</a><a href="#associatedtype.IntoIter" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.IntoIter.html" title="struct prefix_trie::joint::map::IntoIter">IntoIter</a>&lt;P, T&gt;</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/iter.rs.html#188-193">Source</a><a href="#method.into_iter" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.91.1/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CJointPrefixMap%3CP,+R%3E%3E-for-JointPrefixMap%3CP,+L%3E" class="impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#1219-1229">Source</a><a href="#impl-PartialEq%3CJointPrefixMap%3CP,+R%3E%3E-for-JointPrefixMap%3CP,+L%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P, L, R&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, R&gt;&gt; for <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, L&gt;<div class="where">where
    P: <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a> + <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>,
    L: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;R&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#1224-1228">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, R&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.91.1/src/core/cmp.rs.html#264">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><section id="impl-Eq-for-JointPrefixMap%3CP,+T%3E" class="impl"><a class="src rightside" href="../../../src/prefix_trie/joint\map/mod.rs.html#1231-1236">Source</a><a href="#impl-Eq-for-JointPrefixMap%3CP,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;<div class="where">where
    P: <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a> + <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a>,
    T: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a>,</div></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-JointPrefixMap%3CP,+T%3E" class="impl"><a href="#impl-Freeze-for-JointPrefixMap%3CP,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P, T&gt; !<a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;</h3></section><section id="impl-RefUnwindSafe-for-JointPrefixMap%3CP,+T%3E" class="impl"><a href="#impl-RefUnwindSafe-for-JointPrefixMap%3CP,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P, T&gt; !<a class="trait" href="https://doc.rust-lang.org/1.91.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;</h3></section><section id="impl-Send-for-JointPrefixMap%3CP,+T%3E" class="impl"><a href="#impl-Send-for-JointPrefixMap%3CP,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;<div class="where">where
    &lt;P as <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a>&gt;::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P1" title="type prefix_trie::joint::JointPrefix::P1">P1</a>: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,
    T: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,
    &lt;P as <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a>&gt;::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P2" title="type prefix_trie::joint::JointPrefix::P2">P2</a>: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</div></h3></section><section id="impl-Sync-for-JointPrefixMap%3CP,+T%3E" class="impl"><a href="#impl-Sync-for-JointPrefixMap%3CP,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;<div class="where">where
    &lt;P as <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a>&gt;::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P1" title="type prefix_trie::joint::JointPrefix::P1">P1</a>: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,
    T: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,
    &lt;P as <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a>&gt;::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P2" title="type prefix_trie::joint::JointPrefix::P2">P2</a>: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</div></h3></section><section id="impl-Unpin-for-JointPrefixMap%3CP,+T%3E" class="impl"><a href="#impl-Unpin-for-JointPrefixMap%3CP,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;<div class="where">where
    &lt;P as <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a>&gt;::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P1" title="type prefix_trie::joint::JointPrefix::P1">P1</a>: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    &lt;P as <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a>&gt;::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P2" title="type prefix_trie::joint::JointPrefix::P2">P2</a>: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    T: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-JointPrefixMap%3CP,+T%3E" class="impl"><a href="#impl-UnwindSafe-for-JointPrefixMap%3CP,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap">JointPrefixMap</a>&lt;P, T&gt;<div class="where">where
    &lt;P as <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a>&gt;::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P1" title="type prefix_trie::joint::JointPrefix::P1">P1</a>: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,
    &lt;P as <a class="trait" href="../trait.JointPrefix.html" title="trait prefix_trie::joint::JointPrefix">JointPrefix</a>&gt;::<a class="associatedtype" href="../trait.JointPrefix.html#associatedtype.P2" title="type prefix_trie::joint::JointPrefix::P2">P2</a>: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,
    T: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.91.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.91.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.91.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.91.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/clone.rs.html#515">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/clone.rs.html#517">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.91.1/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/1.91.1/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="../../../src/either/into_either.rs.html#64">Source</a><a href="#impl-IntoEither-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="../../../src/either/into_either.rs.html#29">Source</a><a href="#method.into_either" class="anchor">§</a><h4 class="code-header">fn <a href="../../../either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="../../../either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;</h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="../../../either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="../../../either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="../../../either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="../../../either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="../../../either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="../../../src/either/into_either.rs.html#55-57">Source</a><a href="#method.into_either_with" class="anchor">§</a><h4 class="code-header">fn <a href="../../../either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="../../../either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="../../../either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="../../../either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="../../../either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="../../../either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="../../../either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/alloc/borrow.rs.html#85-87">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/alloc/borrow.rs.html#89">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.1/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/alloc/borrow.rs.html#90">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.91.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/alloc/borrow.rs.html#94">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.91.1/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.1/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"Cover<'a, 'p, P, T>":"<h3>Notable traits for <code><a class=\"enum\" href=\"enum.Cover.html\" title=\"enum prefix_trie::joint::map::Cover\">Cover</a>&lt;'a, '_, P, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"enum\" href=\"enum.Cover.html\" title=\"enum prefix_trie::joint::map::Cover\">Cover</a>&lt;'a, '_, P, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (P, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.91.1/std/primitive.reference.html\">&amp;'a T</a>);</div>","CoverKeys<'a, 'p, P, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.CoverKeys.html\" title=\"struct prefix_trie::joint::map::CoverKeys\">CoverKeys</a>&lt;'_, '_, P, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.CoverKeys.html\" title=\"struct prefix_trie::joint::map::CoverKeys\">CoverKeys</a>&lt;'_, '_, P, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = P;</div>","CoverValues<'a, 'p, P, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.CoverValues.html\" title=\"struct prefix_trie::joint::map::CoverValues\">CoverValues</a>&lt;'a, '_, P, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.CoverValues.html\" title=\"struct prefix_trie::joint::map::CoverValues\">CoverValues</a>&lt;'a, '_, P, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.91.1/std/primitive.reference.html\">&amp;'a T</a>;</div>","CoveringDifference<'a, P, T, R>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.CoveringDifference.html\" title=\"struct prefix_trie::joint::map::CoveringDifference\">CoveringDifference</a>&lt;'a, P, L, R&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, L, R&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.CoveringDifference.html\" title=\"struct prefix_trie::joint::map::CoveringDifference\">CoveringDifference</a>&lt;'a, P, L, R&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (P, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.91.1/std/primitive.reference.html\">&amp;'a L</a>);</div>","Difference<'a, P, T, R>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Difference.html\" title=\"struct prefix_trie::joint::map::Difference\">Difference</a>&lt;'a, P, L, R&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, L, R&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Difference.html\" title=\"struct prefix_trie::joint::map::Difference\">Difference</a>&lt;'a, P, L, R&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"struct.DifferenceItem.html\" title=\"struct prefix_trie::joint::map::DifferenceItem\">DifferenceItem</a>&lt;'a, P, L, R&gt;;</div>","Intersection<'a, P, T, R>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Intersection.html\" title=\"struct prefix_trie::joint::map::Intersection\">Intersection</a>&lt;'a, P, L, R&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, L, R&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Intersection.html\" title=\"struct prefix_trie::joint::map::Intersection\">Intersection</a>&lt;'a, P, L, R&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (P, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.91.1/std/primitive.reference.html\">&amp;'a L</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.91.1/std/primitive.reference.html\">&amp;'a R</a>);</div>","IntoIter<P, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.IntoIter.html\" title=\"struct prefix_trie::joint::map::IntoIter\">IntoIter</a>&lt;P, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.IntoIter.html\" title=\"struct prefix_trie::joint::map::IntoIter\">IntoIter</a>&lt;P, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.91.1/std/primitive.tuple.html\">(P, T)</a>;</div>","IntoKeys<P, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.IntoKeys.html\" title=\"struct prefix_trie::joint::map::IntoKeys\">IntoKeys</a>&lt;P, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.IntoKeys.html\" title=\"struct prefix_trie::joint::map::IntoKeys\">IntoKeys</a>&lt;P, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = P;</div>","IntoValues<P, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.IntoValues.html\" title=\"struct prefix_trie::joint::map::IntoValues\">IntoValues</a>&lt;P, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.IntoValues.html\" title=\"struct prefix_trie::joint::map::IntoValues\">IntoValues</a>&lt;P, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = T;</div>","Iter<'_, P, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Iter.html\" title=\"struct prefix_trie::joint::map::Iter\">Iter</a>&lt;'a, P, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Iter.html\" title=\"struct prefix_trie::joint::map::Iter\">Iter</a>&lt;'a, P, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (P, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.91.1/std/primitive.reference.html\">&amp;'a T</a>);</div>","Iter<'a, P, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Iter.html\" title=\"struct prefix_trie::joint::map::Iter\">Iter</a>&lt;'a, P, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Iter.html\" title=\"struct prefix_trie::joint::map::Iter\">Iter</a>&lt;'a, P, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (P, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.91.1/std/primitive.reference.html\">&amp;'a T</a>);</div>","IterMut<'_, P, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.IterMut.html\" title=\"struct prefix_trie::joint::map::IterMut\">IterMut</a>&lt;'a, P, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.IterMut.html\" title=\"struct prefix_trie::joint::map::IterMut\">IterMut</a>&lt;'a, P, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (P, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.91.1/std/primitive.reference.html\">&amp;'a mut T</a>);</div>","IterMut<'a, P, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.IterMut.html\" title=\"struct prefix_trie::joint::map::IterMut\">IterMut</a>&lt;'a, P, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.IterMut.html\" title=\"struct prefix_trie::joint::map::IterMut\">IterMut</a>&lt;'a, P, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (P, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.91.1/std/primitive.reference.html\">&amp;'a mut T</a>);</div>","Keys<'_, P, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Keys.html\" title=\"struct prefix_trie::joint::map::Keys\">Keys</a>&lt;'_, P, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Keys.html\" title=\"struct prefix_trie::joint::map::Keys\">Keys</a>&lt;'_, P, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = P;</div>","Union<'a, P, T, R>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Union.html\" title=\"struct prefix_trie::joint::map::Union\">Union</a>&lt;'a, P, L, R&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, L, R&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Union.html\" title=\"struct prefix_trie::joint::map::Union\">Union</a>&lt;'a, P, L, R&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"enum.UnionItem.html\" title=\"enum prefix_trie::joint::map::UnionItem\">UnionItem</a>&lt;'a, P, L, R&gt;;</div>","Values<'_, P, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Values.html\" title=\"struct prefix_trie::joint::map::Values\">Values</a>&lt;'a, P, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Values.html\" title=\"struct prefix_trie::joint::map::Values\">Values</a>&lt;'a, P, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.91.1/std/primitive.reference.html\">&amp;'a T</a>;</div>","ValuesMut<'_, P, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.ValuesMut.html\" title=\"struct prefix_trie::joint::map::ValuesMut\">ValuesMut</a>&lt;'a, P, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"../trait.JointPrefix.html\" title=\"trait prefix_trie::joint::JointPrefix\">JointPrefix</a>, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.ValuesMut.html\" title=\"struct prefix_trie::joint::map::ValuesMut\">ValuesMut</a>&lt;'a, P, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.91.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.91.1/std/primitive.reference.html\">&amp;'a mut T</a>;</div>"}</script></section></div></main></body></html>