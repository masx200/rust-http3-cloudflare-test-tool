<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate provides a simple prefix tree for IP prefixes. Any lookup performs longest-prefix match. This crate supports both IPv4 and IPv6 (from either ipnet or ipnetwork or cidr). It also  supports any tuple `(R, u8)`, where `R` is any unsigned primitive integer (`u8`, `u16`, `u32`, `u64`, `u128`, or `usize`)."><title>prefix_trie - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="prefix_trie" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.1 (ed61e7d7e 2025-11-07)" data-channel="1.91.1" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate prefix_trie</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../prefix_trie/index.html">prefix_<wbr>trie</a><span class="version">0.8.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#comparison-with-related-projects" title="Comparison with related projects">Comparison with related projects</a></li><li><a href="#description-of-the-tree" title="Description of the Tree">Description of the Tree</a></li><li><a href="#traversals" title="Traversals">Traversals</a></li><li><a href="#trieview-and-trieviewmut" title="`TrieView` and `TrieViewMut`"><code>TrieView</code> and <code>TrieViewMut</code></a></li><li><a href="#operations-on-the-tree" title="Operations on the tree">Operations on the tree</a></li><li><a href="#todo" title="TODO">TODO</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>prefix_<wbr>trie</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/prefix_trie/lib.rs.html#1-134">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate provides a simple prefix tree for IP prefixes. Any lookup performs longest-prefix
match. This crate supports both IPv4 and IPv6 (from either <a href="https://docs.rs/ipnet/2.10.0">ipnet</a>
or <a href="https://crates.io/crates/ipnetwork">ipnetwork</a> or <a href="https://crates.io/crates/cidr">cidr</a>).
It also  supports any tuple <code>(R, u8)</code>, where <code>R</code> is any unsigned primitive integer (<code>u8</code>, <code>u16</code>,
<code>u32</code>, <code>u64</code>, <code>u128</code>, or <code>usize</code>).</p>
<p>This crate also provides a <a href="joint/map/struct.JointPrefixMap.html" title="struct prefix_trie::joint::map::JointPrefixMap"><code>joint::JointPrefixMap</code></a> and <a href="joint/set/struct.JointPrefixSet.html" title="struct prefix_trie::joint::set::JointPrefixSet"><code>joint::JointPrefixSet</code></a> that contains
two tables, one for IPv4 and one for IPv6.</p>
<h2 id="comparison-with-related-projects"><a class="doc-anchor" href="#comparison-with-related-projects">§</a>Comparison with related projects</h2>
<p><a href="https://crates.io/crates/ip_network_table-deps-treebitmap"><code>ip_network_table-deps-treebitmap</code></a>
provides an IP lookup table, similar to <a href="map/struct.PrefixMap.html" title="struct prefix_trie::map::PrefixMap"><code>PrefixMap</code></a>.</p>
<p>The following compares the two approaches in the case of <em>dense</em> or <em>sparse</em> maps. Each test
case performs 100’000 modifications or lookups. However, the dense cases randomly picks any IPv4
address, while the sparse case only pick 20 different IPv4 addresses. See <code>benches/benchmark.rs</code>
for more details.</p>
<div><table><thead><tr><th>Operation</th><th>Mode</th><th><code>PrefixMap</code></th><th><code>treebitmap</code></th><th>factor</th></tr></thead><tbody>
<tr><td>Insert &amp; Remove</td><td>dense</td><td><strong>31.78ms</strong></td><td>47.52ms</td><td>~1.5x</td></tr>
<tr><td>Lookup</td><td>dense</td><td>32.36ms</td><td><strong>8.409ms</strong></td><td>~0.25x</td></tr>
<tr><td>Insert &amp; Remove</td><td>sparse</td><td><strong>6.645ms</strong></td><td>7.329ms</td><td>~1.1x</td></tr>
<tr><td>Lookup</td><td>sparse</td><td><strong>8.394ms</strong></td><td>12.30ms</td><td>~1.5x</td></tr>
</tbody></table>
</div>
<p>In addition, <code>prefix-trie</code> includes a <a href="set/struct.PrefixSet.html" title="struct prefix_trie::set::PrefixSet"><code>PrefixSet</code></a> analogous to <code>std::collections::HashSet</code>,
including union, intersection and difference operations that are implemented as simultaneous
tree traversals. Further, <code>prefix-trie</code> has an interface similar to <code>std::collections</code>, and
offers a general longest-prefix match that is not limited to individual addresses. Finally,
<code>prefix-trie</code> allows you to (mutably) borrow a sub-trie using views.</p>
<h2 id="description-of-the-tree"><a class="doc-anchor" href="#description-of-the-tree">§</a>Description of the Tree</h2>
<p>The tree is structured as follows: Each node consists of a prefix, a container for a potential
value (<code>Option</code>), and two optional children. Adding a new child, or traversing into the tree is
done as follows: we look at the most significant bit that is <strong>not</strong> part of the prefix
itself. If it is not set, then we take the left branch, and otherwise, we take the right one.</p>
<h2 id="traversals"><a class="doc-anchor" href="#traversals">§</a>Traversals</h2>
<p>Any iteration over all elements in the tree is implemented as a graph traversal that will yield
elements in lexicographic order.</p>
<p>The library offers set operations of different maps or sets. We implement a union, intersection,
difference, and covering_difference. These iterators are implemented using simultaneous tree
traversals. They will yield elements in lexicographic order. Whenever appropriate, the yielded
items will also include the longest prefix match.</p>
<h2 id="trieview-and-trieviewmut"><a class="doc-anchor" href="#trieview-and-trieviewmut">§</a><a href="trieview/struct.TrieView.html" title="struct prefix_trie::trieview::TrieView"><code>TrieView</code></a> and <a href="trieview/struct.TrieViewMut.html" title="struct prefix_trie::trieview::TrieViewMut"><code>TrieViewMut</code></a></h2>
<p>You can create a view of a (sub)-trie. Such a view has an any node as its root. Any operations
on that view will only traverse that node and all its children. You can iterate over all
children, search in that sub-trie, and perform set operations (union, intersection, difference,
or the covering difference) on them.</p>
<p>A view can point to one of three possible nodes:</p>
<ul>
<li>A node in the tree that is actually present in the map,</li>
<li>A branching node that does not exist in the map, but is needed for the tree structure (or that
was deleted using the function <code>remove_keep_tree</code>)</li>
<li>A virtual node that does not exist as a node in the tree. This is only the case if you call
<a href="trieview/struct.TrieView.html#method.find" title="method prefix_trie::trieview::TrieView::find"><code>TrieView::find</code></a> or <a href="trieview/trait.AsView.html#method.view_at" title="method prefix_trie::trieview::AsView::view_at"><code>AsView::view_at</code></a> with a node that is not present in the tree, but
that contains elements present in the tree. Virtual nodes are treated as if they are actually
present in the tree as branching nodes.</li>
</ul>
<h2 id="operations-on-the-tree"><a class="doc-anchor" href="#operations-on-the-tree">§</a>Operations on the tree</h2>
<p>There are several operations one can do on the tree. Regular inserts are handled using the
<code>Entry</code> structure. An <code>Entry</code> is a pointer to a location in the tree to either insert a value or
modify an existing one. Removals however are different.</p>
<p>The following are the computational complexities of the functions, where <code>n</code> is the number of
elements in the tree.</p>
<div><table><thead><tr><th>Operation</th><th>Complexity</th></tr></thead><tbody>
<tr><td><code>entry</code>, <code>insert</code></td><td><code>O(log n)</code></td></tr>
<tr><td><code>remove</code>, <code>remove_keep_tree</code></td><td><code>O(log n)</code></td></tr>
<tr><td><code>remove_children</code> (calling <code>drop</code> on <code>T</code>)</td><td><code>O(n)</code></td></tr>
<tr><td><code>get</code>, <code>get_lpm</code>, <code>get_mut</code></td><td><code>O(log n)</code></td></tr>
<tr><td><code>retain</code></td><td><code>O(n)</code></td></tr>
<tr><td><code>clear</code> (calling <code>drop</code> on <code>T</code>)</td><td><code>O(n)</code></td></tr>
<tr><td>Operations on <a href="map/enum.Entry.html" title="enum prefix_trie::map::Entry"><code>map::Entry</code></a></td><td><code>O(1)</code></td></tr>
<tr><td><code>len</code> and <code>is_empty</code></td><td><code>O(1)</code></td></tr>
<tr><td><code>union</code>, <code>intersection</code>, <code>difference</code>, …</td><td><code>O(n)</code></td></tr>
</tbody></table>
</div>
<p>There are three kinds of removals you! can do:</p>
<ul>
<li><a href="map/struct.PrefixMap.html#method.remove" title="method prefix_trie::map::PrefixMap::remove"><code>PrefixMap::remove</code></a> will remove an entry from the tree and modify the tree structure as if
the value was never inserted before. <a href="map/struct.PrefixMap.html#method.remove" title="method prefix_trie::map::PrefixMap::remove"><code>PrefixMap::remove</code></a> will always exactly revert the
operation of <a href="map/struct.PrefixMap.html#method.insert" title="method prefix_trie::map::PrefixMap::insert"><code>PrefixMap::insert</code></a>. When only calling this function to remove elements, you
are guaranteed that the tree structure is indistinguishable to a different tree where you
only inserted elements.</li>
<li><a href="map/struct.PrefixMap.html#method.remove_children" title="method prefix_trie::map::PrefixMap::remove_children"><code>PrefixMap::remove_children</code></a> will remove all entries that are contained within the given
prefix. This operation will search for the node with the shortest prefix length that is
contained within the given prefix and remove it, including all of its children.</li>
<li><a href="map/struct.PrefixMap.html#method.remove_keep_tree" title="method prefix_trie::map::PrefixMap::remove_keep_tree"><code>PrefixMap::remove_keep_tree</code></a> will not change anything in the tree structure. It will only
remove a value from a node. As soon as you call <code>remove_keep_tree</code> once on a tree structure,
the tree will no longer be optimal.</li>
</ul>
<h2 id="todo"><a class="doc-anchor" href="#todo">§</a>TODO</h2>
<p>Migrate to a TreeBitMap, described by
<a href="https://doi.org/10.1145/997150.997160">W. Eatherton, Z. Dittia, G. Varghes</a>.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.PrefixMap"><code>pub use map::<a class="struct" href="map/struct.PrefixMap.html" title="struct prefix_trie::map::PrefixMap">PrefixMap</a>;</code></dt><dt id="reexport.PrefixSet"><code>pub use set::<a class="struct" href="set/struct.PrefixSet.html" title="struct prefix_trie::set::PrefixSet">PrefixSet</a>;</code></dt><dt id="reexport.AsView"><code>pub use trieview::<a class="trait" href="trieview/trait.AsView.html" title="trait prefix_trie::trieview::AsView">AsView</a>;</code></dt><dt id="reexport.AsViewMut"><code>pub use trieview::<a class="trait" href="trieview/trait.AsViewMut.html" title="trait prefix_trie::trieview::AsViewMut">AsViewMut</a>;</code></dt><dt id="reexport.TrieView"><code>pub use trieview::<a class="struct" href="trieview/struct.TrieView.html" title="struct prefix_trie::trieview::TrieView">TrieView</a>;</code></dt><dt id="reexport.TrieViewMut"><code>pub use trieview::<a class="struct" href="trieview/struct.TrieViewMut.html" title="struct prefix_trie::trieview::TrieViewMut">TrieViewMut</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="joint/index.html" title="mod prefix_trie::joint">joint</a></dt><dd>Module that defines the joint version of a prefix map and set, including all helper
functions. You can access each individual table of the prefix map, allowing you to perform the
usual operations set operations.</dd><dt><a class="mod" href="map/index.html" title="mod prefix_trie::map">map</a></dt><dd>Implementation of the Prefix Map.</dd><dt><a class="mod" href="set/index.html" title="mod prefix_trie::set">set</a></dt><dd>PrefixSet, that is implemened as a simple binary tree, based on the <a href="map/struct.PrefixMap.html" title="struct prefix_trie::map::PrefixMap"><code>PrefixMap</code></a>.</dd><dt><a class="mod" href="trieview/index.html" title="mod prefix_trie::trieview">trieview</a></dt><dd>A <a href="trieview/struct.TrieView.html" title="struct prefix_trie::trieview::TrieView"><code>TrieView</code></a> (or a <a href="trieview/struct.TrieViewMut.html" title="struct prefix_trie::trieview::TrieViewMut"><code>TrieViewMut</code></a>) is a pointer to a specific element in a PrefixTrie, representing the sub-tree
rooted at that node.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Prefix.html" title="trait prefix_trie::Prefix">Prefix</a></dt><dd>Trait for defining prefixes.</dd></dl></section></div></main></body></html>